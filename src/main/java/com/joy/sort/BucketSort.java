package com.joy.sort;

/**
 * 桶排序
 * 将数据抽取到几个有序桶里，每个桶里数据进行单独排序，桶内排序完以后，进行合并
 * 复杂度为O(n)的排序算法
 * 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。
 * 首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。
 *
 * 其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。
 * @author Joy
 * @date 2022-11-28
 */
public class BucketSort {

    /**
     * 问：10GB的订单数据，按照金额进行排序，但是内存较小，只有几百M，该如何处理？
     */

    /**
     * 思路：
     * 1.首先遍历所有订单数据，判断订单金额所处范围，如果最小1元，最大10万，可以按照1000的金额区间分成100个桶里，每个桶对应1个文件
     * 2.理想情况下，每个文件都是均匀的，即大概100M左右，每个文件内的数据单独使用快排进行排序（如果不均匀会退化成nlogn复杂度的算法）
     * 3.按照桶编号，依次读取每个桶内的数据，写入到一个新的容器，新的容器就是有序的了，可以使用内存每次读满数据写入到新文件
     * 4.极端情况，如果某个区间内的数量很多，则可以继续按照金额划分
     */




}
